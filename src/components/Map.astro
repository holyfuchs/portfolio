---
// Import Three.js
---

<div id="world-map" class="w-full h-[500px]">
    <canvas id="map-canvas"></canvas>
  </div>
  
  <script>
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
  
    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
  
    // Create camera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 200;
  
    // Create renderer
    const canvas = document.querySelector('#map-canvas');
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
    });
    
    const container = document.querySelector('#world-map');
    renderer.setSize(container.clientWidth, container.clientHeight);
  
    // Add orbit controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 100;
    controls.maxDistance = 500;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
  
    // Create Earth sphere with wireframe
    const radius = 100;
    const segments = 64;
    const geometry = new THREE.SphereGeometry(radius, segments, segments);
    
    // Create wireframe material
    const wireframeMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ff00,
      wireframe: true,
      transparent: true,
      opacity: 0.3
    });
  
    // Create glow material
    const glowMaterial = new THREE.ShaderMaterial({
      uniforms: {
        c: { type: "f", value: 0.1 },
        p: { type: "f", value: 3.0 },
        glowColor: { type: "c", value: new THREE.Color(0x00ff00) },
      },
      vertexShader: `
        varying vec3 vNormal;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 glowColor;
        uniform float c;
        uniform float p;
        varying vec3 vNormal;
        void main() {
          float intensity = pow(c - dot(vNormal, vec3(0.0, 0.0, 1.0)), p);
          gl_FragColor = vec4(glowColor, intensity);
        }
      `,
      side: THREE.BackSide,
      blending: THREE.AdditiveBlending,
      transparent: true
    });
  
    // Create main sphere and glow sphere
    const earth = new THREE.Mesh(geometry, wireframeMaterial);
    const glowSphere = new THREE.Mesh(
      new THREE.SphereGeometry(radius * 1.2, segments, segments),
      glowMaterial
    );
    
    scene.add(earth);
    scene.add(glowSphere);
  
    // Function to add marker at specific coordinates
    function addMarker(lat, lon) {
      const markerGeometry = new THREE.SphereGeometry(2, 8, 8);
      const markerMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.8
      });
      
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      
      // Convert latitude and longitude to 3D position
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);
      
      marker.position.x = -(radius * Math.sin(phi) * Math.cos(theta));
      marker.position.z = (radius * Math.sin(phi) * Math.sin(theta));
      marker.position.y = (radius * Math.cos(phi));
      
      earth.add(marker);
      
      // Add pulse effect
      const pulseGeometry = new THREE.SphereGeometry(2, 8, 8);
      const pulseMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.4
      });
      
      const pulse = new THREE.Mesh(pulseGeometry, pulseMaterial);
      pulse.position.copy(marker.position);
      earth.add(pulse);
      
      // Animate pulse
      function animatePulse() {
        pulse.scale.x = pulse.scale.y = pulse.scale.z = 
          1 + Math.sin(Date.now() * 0.005) * 0.5;
      }
      
      return { marker, pulse, animatePulse };
    }
  
    // Add some example markers
    const markers = [
      addMarker(40.7128, -74.0060),  // New York
      addMarker(51.5074, -0.1278),   // London
      addMarker(35.6762, 139.6503),  // Tokyo
      addMarker(-33.8688, 151.2093), // Sydney
    ];
  
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Animate markers
      markers.forEach(marker => marker.animatePulse());
      
      controls.update();
      renderer.render(scene, camera);
    }
  
    // Handle window resize
    function onWindowResize() {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }
  
    window.addEventListener('resize', onWindowResize);
  
    // Start animation
    animate();
  </script>
  
  <style>
    #world-map {
      position: relative;
      width: 100%;
      height: 500px;
      overflow: hidden;
      background: #000;
    }
  
    #map-canvas {
      width: 100%;
      height: 100%;
    }
  </style>